Bu rehber, yazdığın düşük seviyeli `_print` fonksiyonunu herhangi bir projede (C, C++, Rust, Zig veya direkt Assembly) nasıl bir **standart kütüphane modülü** gibi kullanabileceğini adım adım açıklar.

---

## Düşük Seviyeli I/O Modülü (`_print.obj`) Kullanım Rehberi

Bu modül, işletim sistemi bağımlılıklarını (Windows API) soyutlayarak, yüksek seviyeli dillerin ve derleyicilerin doğrudan ekran çıktısı vermesini sağlayan taşınabilir bir nesne dosyasıdır.

### 1. Bileşenlerin Hazırlanması

Öncelikle, assembly kaynak kodunuzu (`_print.s`) her dilden bağlanabilir bir ikili (binary) nesne dosyasına dönüştürmeniz gerekir.

**Derleme Komutu (GCC/MinGW):**

```bash
gcc -c _print.s -o _print.obj

```

### 2. Kütüphane Arayüzü (API) Tanımları

Diğer dillerin bu fonksiyonu tanıyabilmesi için fonksiyon imzasını belirtmek şarttır.

#### **C ve C++ için:**

```c
// print_lib.h
#ifdef __cplusplus
extern "C" {
#endif

// Değişken sayıda argüman alan ana fonksiyon
void _print(const char* format, ...);

#ifdef __cplusplus
}
#endif

```

#### **Zig için:**

```zig
extern fn _print(format: [*:0]const u8, ...) void;

```

#### **Direct Assembly için:**

```assembly
extern _print:proc
# Çağrı: lea rcx, [fmt]; mov rdx, rax; call _print

```

---

### 3. Kullanım Senaryoları ve Entegrasyon

#### **A. C/C++ Projelerinde Kullanım**

Eğer kendi standart kütüphaneni yazıyorsan veya `printf`'e bağımlı olmak istemiyorsan:

```c
#include "print_lib.h"

int main() {
    float pi = 3.141592;
    _print("Merhaba Dunya!\n");
    _print("Hesaplama Sonucu: %f\n", pi);
    return 0;
}

```

**Bağlama (Linking):**
`gcc main.c _print.obj -o uygulama.exe`

#### **B. Derleyici (Compiler) Geliştirmede Kullanım**

Kendi derleyicini yazıyorsan (Rust, Python tabanlı bir derleyici vb.), `_print.obj` dosyasını bir **Runtime Library** parçası olarak dağıtabilirsin.

1. Derleyicin, print komutu gördüğünde `call _print` assembly kodunu üretir.
2. Son aşamada (Linker aşaması), derleyicin otomatik olarak `_print.obj` dosyasını kullanıcının koduyla birleştirir.

---

### 4. Teknik Gereksinimler (Windows x64 ABI)

Bu modülü kullanan her sistem, Windows'un çağrı standartlarına uymak zorundadır. Modülün çalışması için şu 3 kural kritiktir:

1. **Shadow Space:** Fonksiyon çağrılmadan önce `RSP` üzerinden 32 (veya hizalama ile 40) byte boş alan ayrılmalıdır.
2. **Register Sıralaması:** İlk 4 argüman sırasıyla `RCX`, `RDX`, `R8`, `R9` register'larında olmalıdır.
3. **Hizalama:** `call` komutu verildiği anda `RSP` değeri 16-byte hizalı olmalıdır.

---

### 5. Modülün Avantajları

* **Minimalizm:** `msvcrt.dll` veya ağır standart kütüphanelere olan bağımlılığı azaltır.
* **Doğrudan Donanım Erişimi:** Float işlemleri için doğrudan `XMM` register'larını kullanarak yüksek performans sağlar.
* **Bağımsızlık:** Herhangi bir dilden (Native destekleyen) çağrılabilir; çünkü `C` tipi çağırma konvansiyonuna (`extern "C"`) uygundur.

---

### 6. Gelecek Geliştirmeler İçin Not

Bu modülü bir kütüphane haline getirdiğinde, yanına bir `_scanf.obj` (giriş için) ve `_file.obj` (dosya işlemleri için) ekleyerek kendi **Core SDK**'nı oluşturabilirsin.
